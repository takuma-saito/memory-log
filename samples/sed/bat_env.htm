<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

  <!--   still being edited : not yet ready for release --->

<head>
  <title>Getting Data into Environment Variables under MS-DOS</title>
  <meta name="keywords" content="environment, variables, MS-DOS, DOS, Windows, WinNT, Win2K, Win95, Win98, WinME">
  <meta name="description" content="How to extract data from disk or console to put into environment variables for DOS and Windows">
<link rel=STYLESHEET style="text/css" href="../css/style.css">
<style type="text/css">
<!--
 body {
   font-family: Verdana,"Times New Roman",Times,serif; 
   margin: 10px 25px;
 }
 
 p, dd, dt  {
   font-family: Verdana, "Times New Roman",Times,serif;
   font-size: 10pt;
}

.grey {
   background-color: #F2F2F2;
   color: black;
   padding-left: 20px;
   padding-right: 20px;
   padding-top: 5px;
   padding-bottom: 5px;
   border: groove darkred 1px;
}
-->
</style>
</head>

<body bgcolor="#FFFFFF">

<h1>Getting Console or Disk Data into Environment Variables<br>
    under MS-DOS and Windows</h1>

<p><B>5th edition</B> by Eric Pement
&lt;<a href="mailto:pemente@northpark.edu" name="mailme">pemente@northpark.edu</a>&gt;<br>
Oct. 15, 2002 (answers rearranged, many new things added)</p>


<p>Since this file was first developed in 1998, I have found nearly a
 dozen different ways to address this problem. What began as a one- or
 two-page response has increased with each version. This 5<sup>th</sup>
 edition is a vast rearrangement over the previous versions.</p>

<p>The task is to get strings either (a) typed at the keyboard, or (b)
printed to the screen, or (c) residing in a diskfile, and put those
strings into an environment variable. The operating system is MS-DOS
or Windows or maybe Windows 2000/WinNT.</p> 

<p>I list the solutions in order of ease-of-use (my subjective opinion).
 My personal favorite is #1, since I'm a licensed user of 4DOS. If I couldn't
 use 4DOS, my next choice would be #2, an external utility dedicated to this
 task. I list <tt>sed</tt> and <tt>awk</tt> as a separate solution (#3),
 even though they are also "external utilities", simply because I know a
 lot about them and because they are extremely <i>safe</i>. (In other words,
 they've been around for many years, you can get the source code, and the
 main distribution points are known to be virus-free, if that's a concern.)</p>
 
<P>If you are unable or unwilling to install third-party software on your
 DOS or Windows computer, your alternative is to select one of six different
 solutions that best fits your needs from #4.</p>

<table border="0" bgcolor="white"><tr><td align="left" class="grey">
<b><u>Select one of the following methods:</u></b>
<ol type="1">
  <li>Use <a href="#4dos">4DOS</a> by JP Software (replaces <code>COMMAND.COM</code>)
  <li>Use one of several free, <a href="#utils">external utilities</a> made for this task<br>
      Plus: Making it work under <a href="#NT">Windows NT</a></li>
  <li>Use <a href="#sed">sed or awk</a> (widely available freeware)
  <li>Solutions that use pure MS-DOS only:</li>
      <ol type="a">
         <li>Embed a single <a href="#linefeed">linefeed</a> in the batch file</li>
         <li>Prompt the user to <a href="#type">type a line</a></li>
         <li>Use <a href="#debug">DEBUG</a> to create a temporary file</li>
         <li>Use <a href="#echo">ECHO</a> to create intermediate file</li>
         <li>Get <a href="#firstword">first word</a> of a textfile into a variable</li>
         <li>Get <a href="#firstline">first line</a> of a textfile into a variable</li>
      </ol>
</ol></td></tr></table>

<p>I would be remiss if I did not give credit to several people who have
 been invaluable in providing key solutions over the years. These people
 include: Tom Lavedas, Ted Davis, "Outsider", Benny Pederson, John Savage,
 Herbert Kleebauer, Gerard Piette, and Timo Salmi. If I have forgotten to
 credit anyone else, please let me know and I'll remedy the omission.</p>

<hr>

<a name="4dos"></a>
<h2>METHOD 1 (uses 4DOS or 4NT)</h2>

<p>Under <a href="http://www.jpsoft.com/4dosdes.htm">4DOS</a>, getting data
into environment variables is simple. 4DOS is a commmand
interpreter (shell) replacement for <CODE>COMMAND.COM</CODE>. It is
commercial software, written by <a href="http://www.jpsoft.com">JP Software</a>,
so this solution requires that you have paid a license for 4DOS,
<a href="http://www.jpsoft.com/4ntdes.htm">4NT</a>, or
<a href="http://jpsoft.com/tcmddes.htm">"Take Command"</a> (the current
single-user cost is about $70). However, to me the numerous advantages of
4DOS are worth parying for. 4NT is preferred for users of Windows NT and
Windows 2000.</p>

<pre>
   echo 1234 | input %%myvar             ; puts "1234" into <I>%myvar%</I>
   set myvar=%@line[MYFILE,5]            ; puts line 6 into <I>%myvar%</I>
   set myfar=%@word[4,%@line[MYFILE,6]]  ; puts 5th word of line 7 into <I>%myvar%</I>
</pre>

<p>The only notable thing about this syntax is that words and lines are
 numbered beginning with 0, not 1. Thus the desired word and line number
 should be decremented by 1 when passing the value to the 4DOS
 or 4NT <KBD>%@line[]</KBD> function. 4DOS also permits words to be pulled
 from the right end of a line, as well.</p>

<hr>
<a name="utils"></a>
<h2>METHOD 2 (uses freeware, dedicated programs)</h2>

<p>For those who prefer freeware solutions and don't need/want the immense
power offered by 4DOS/4NT, here is the easiest solution for most people. It
uses separate utilities, such as <CODE>STRINGS</CODE> or <CODE>ASET</CODE>,
to directly create the environment variables. These utilities permit a
variety of string manipulation, as well as math functions.</p>

<h3>For MS-DOS or Windows 98 (and earlier versions)</h3>

<p>If you run Windows NT, Win2000, or WinXP, click <a href="#NT">here</a>.</p>

<p>I recommend <CODE>STRINGS</CODE> v2.5 by Douglas Boling (<I>PC
Magazine</I>) and <CODE>ASET</CODE> v1.0 by Richard Breuer because they are
freeware and are easily available on the Internet. <CODE>STRINGS</CODE> comes
with ASM source code included. Consider these four examples of obtaining
console output:</p>

<pre>
  echo Greetings!            # prints "Greetings!" to screen
  wc -l &lt; myfile             # prints "1234" to screen
  echo. | date | find "199"  # prints "Current date is Thu 12-17-1998"
  calc 7 + 33                # prints "40" to screen
</pre>

<p>
You will find that <CODE>STRINGS</CODE> and <CODE>ASET</CODE> easily put these into variables:
</p>

<pre>
  echo Greetings! | STRINGS hi=ASK     # puts "Greetings!" into <VAR>%hi%</VAR>
  wc -l &lt; myfile |  STRINGS num=ASK    # puts "1234" into <VAR>%num%</VAR>
  STRINGS hi=LEFT Greetings!,10        # puts "Greetings!" into <VAR>%hi%</VAR>
  STRINGS today=date                   # uses internal date function
  STRINGS now=time                     # uses internal time function
  STRINGS sum=ADD 7,33                 # uses internal math function
  calc 7 + 33 | STRINGS sum=ASK        # or use calc to create <VAR>%sum%</VAR>

  echo Greetings! | ASET hi=line       # puts "Greetings!" into <VAR>%hi%</VAR>
  wc -l &lt; myfile | ASET num=line       # puts "1234" into <VAR>%num%</VAR>
  ASET hi='Greetings!'                 # puts "Greetings!" into <VAR>%hi%</VAR>
  ASET today=date                      # uses internal date function
  ASET now=time                        # uses internal time function
  ASET sum=7+33                        # uses internal math function
  calc 7 + 33 | ASET sum=line          # or use calc to create <VAR>%sum%</VAR>
</pre>

<p>
If your data exists on disk, both <CODE>STRINGS</CODE> and <CODE>ASET</CODE>
are able to access diskfiles on a line-oriented basis. For example:</p>


<pre>
  STRINGS var=read MYFILE,3       # put line 3 of MYFILE into <VAR>%var%</VAR>
  ASET var=LINE(3,'MYFILE')       # put line 3 of MYFILE into <VAR>%var%</VAR>
</pre>


<p>If you want to prompt the user for a string of words or letters, and then
put that string in a variable, both <CODE>STRINGS</CODE> and <CODE>ASET</CODE>
can do that easily. <CODE>ASET</CODE>'s <code>getstr()</code> function will
also permit cursor movement foreward and backward, including insert and
delete, before pressing the <KBD>RETURN</KBD> key. These examples should
illustrate:</p>


<pre>
  <u><i>Sample <b>STRINGS</b> usage</i></u>:                        <I><U>Sample <b>ASET</b> usage</U>:</I>
  @echo off                                    @echo off
  strings var=ask Enter your full name:        echo Enter your full name:
  echo The user typed /%var/.                  aset var=line
                                               echo The user typed /%var/.
</pre>


<pre>
  <u><i>Advanced <b>STRINGS</b> features:</i></u>
  @echo off
  ::   variable length a max of 20 chars, "1" means mask chars with asterisks
  strings var=ask Enter your password: ,20,1
  echo The password is :%var:

  <u><i>Advanced <b>ASET</b> features:</i></u>
  @echo off
  :: use <kbd>CLS</kbd> to move the prompt to line 1
  cls
  echo Enter your password:
  ::   args are (max-length,'default string',row,column)
  aset var=getstr(20,'joshua',1,21)
  echo.
  echo The password is :%var:
</pre>

<p>
Both <CODE>STRINGS</CODE> and <CODE>ASET</CODE> have a wide range of
functions to generate data on time, date, math, file, disk, memory, and other
values, and to transform or parse strings (lowercase, uppercase, substrings,
count words, etc.). They are extremely flexible, not too large (14k and 100k
respectively), and are free of charge.</p>

<pre>
  STRINGS v2.5
  <a href="ftp://ftp.zdnet.com/pcmag/1992/1222/strings.zip">ftp://ftp.zdnet.com/pcmag/1992/1222/strings.zip</a> (filesize: 75k)
  <a href="./strings.zip">strings.zip</a> (local disk copy)
  
  ASET v1.0
  <a href="ftp://ftp.uwasa.fi/pc/batchutil/aset10.zip">ftp://ftp.uwasa.fi/pc/batchutil/aset10.zip</a> (filesize: 80k)
  <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/batchutl/aset10.zip">ftp://ftp.simtel.net/pub/simtelnet/msdos/batchutl/aset10.zip</a>
</pre>

<br>
<a name="NT"></a><h2>Making it work under Windows NT and Windows 2000</h2>

<p><code>STRINGS</code> and <code>ASET</code> (and most other environment
manipulation utilities) do not work under Windows NT and Windows 2000, even
though they work as advertised in a DOS session or a DOS window under
Microsoft Windows 9x. Why is this, and can it be corrected?</p>

<p>Last question first: No, the problem cannot be corrected. Though Windows 2000
 may complain "not enough environment space" when running <code>STRINGS</code>
 or <code>ASET</code>, the problem is <i>not</i> due to insufficient
 environment space. The problem is caused by the fact that <code>STRINGS</code>
 and <code>ASET</code> both use the DOS interrupt call INT 21
 to alter environment variables. Windows NT and Windows 2000 are incompatible
 with this common technique. Here are some alternate solutions:</p>
 
<h3>Windows 2000: Get input from keyboard</h3>

<p>To prompt the user for a value and then put their keyboard reply into an
environment variable, run this command:</p>
<PRE>
   SET /P VARNAME=Please enter your name:
</PRE>

<p>SET will display the prompt "Please enter your name:" to the user, 
who is expected to type a string of lettes and press <kbd>ENTER</kbd>.
Whatever they type will be stored in the variable <var>%VARNAME</var>,
where it can be retrieved for later operations.</p>

<h3>Windows NT: Get input from keyboard</h3>

<P>This technique doesn't work with Windows NT. However, Simon
Sheppard (<a href="http://www.ss64.com">www.ss64.com</a>) wrote this
script using Windows Scripting Host (present on NT and Win2K machines) to store
user input into an environment variable:</P>

<pre><code>   :: Input1.cmd - A routine to prompt the user for an input string.
   :: Requires WSH version 1.0 or later.
   :: Input string is stored in the variable v_input
   :: Use optional command line argument UCASE to convert input to all uppercase.

   :: usage:
   :: input1
   :: input1 ucase

   @ECHO off
   SETLOCAL
   SET v_vbs=%TEMP%\~tmp.VBS
   SET v_cmd=%TEMP%\~tmp.cmd

   ECHO Set oFS=CreateObject("Scripting.FileSystemObject")>%v_vbs%
   ECHO oFS.OpenTextFile("CON",2).Write "Enter a string: ">>%v_vbs%
   ECHO S=%1(Trim(oFS.OpenTextFile("CON",1).Readline))>>%v_vbs%

   ECHO oFS.CreateTextFile("%v_cmd%",2).Write "set v_input=">>%v_vbs%
   ECHO oFS.OpenTextFile("%v_cmd%",8).Write S>>%v_vbs%

   cscript.exe //nologo %v_vbs%
   CALL %v_cmd%

   DEL %v_vbs%
   DEL %v_cmd%

   SET v_input
   ENDLOCAL & SET v_input=%v_input%
</code></pre>

<p>One workaround is to place the command(s) to these utilities in the file
 called <code>C:\WINNT\AUTOEXEC.NT</code> or
 <code><nobr>C:\%WINDIR%\AUTOEXEC.NT</nobr></code>. The file
 <CODE>AUTOEXEC.NT</CODE> is a "batch" file and it runs like
 <CODE>AUTOEXEC.BAT</CODE> does in normal MS-DOS. If you are able, execute
 <CODE>ASET</CODE> or <CODE>STRINGS</CODE> from within
 <CODE>AUTOEXEC.NT</CODE>. Every time CMD.EXE or COMMAND.COM is executed,
 <CODE>AUTOEXEC.NT</CODE> will be executed, and any variables which are set
 there will persist for the life of the CMD or COMMAND window.</p>

<p>There's probably another workaround, but I don't know what it is right
  now. If someone else does, please <a href="#mailme">e-mail</a> me. Thanks!</p>

<hr>
<a name="sed"></a>
<h2>METHOD 3 (uses sed or awk)</h2>

<p>This method does not require a prepared file like <CODE>PREFIX.DAT</CODE>,
above. However, it does need an external string manipulation program like
<code>sed</CODE> (stream editor) or <code>awk</CODE>, which are available as
freeware for MS-DOS.</p>

<pre>
 sed15/DOS    <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/txtutl/sed15x.zip">ftp://ftp.simtel.net/pub/simtelnet/msdos/txtutl/sed15x.zip</a>
 sed15/Win95  <a href="http://www.cornerstonemag.com/sed/sed15exe.zip"            >http://www.cornerstonemag.com/sed/sed15exe.zip</a>
 gsed 3.02.80 <a href="http://www.student.northpark.edu/pemente/sed/sed3028a.zip" >http://www.student.northpark.edu/pemente/sed/sed3028a.zip</a>
 GNU awk/DOS  <a href="ftp://ftp.simtel.net/pub/simtelnet/gnu/gnuish/gawk306x.zip">ftp://ftp.simtel.net/pub/simtelnet/gnu/gnuish/gawk306x.zip</a>
</pre>

<p>Because <code>sed</CODE> is fairly small (22k for sed15, 84k for gsed) as
compared to <code>awk</CODE> (226k), I often prefer to use
<code>sed</CODE>.</p>

<p>Wherever our data comes from, we must be able to prepend
"<KBD>set&nbsp;value=</KBD>" before the data. If the term is "Jan. 1, 2003",
we must be able to change it to "set value=Jan. 1, 2003". <CODE>Sed</CODE> or
<code>awk</CODE> are superb at doing this.</p>

<p>In Example 1, we'll use console output and <CODE>sed</CODE> to put some
data into a variable. In Example 2, we'll get the data from disk and use
<CODE>awk</CODE> to put the data into a variable. Both techniques use a DOS
batch file.</p>

<p>Example 1: Get today's date and put it into a variable,
<VAR>%DATE%</VAR></p>

<pre>
  @echo off
  :: The output of 'date' in Windows 98 looks like this:
  ::   Current date is Thu 04-11-2002
  ::   Enter new date (mm-dd-yy):
  echo. | date | sed "/2002/!d; s/.* /set date=/" &gt;tmp_.bat
  ::
  call tmp_.bat
  echo Today's date is: [<VAR>%DATE%</VAR>]
  ::
  :: after processing, delete temp file quietly, unset the variable
  del tmp_.bat &gt;NUL
  set date=
</pre>

<p>Example 2: Get John Doe's phone number from <CODE>FOO.DAT</CODE>, and put
it into the variable <VAR>%PHONE%</VAR></p>

<pre>
  @echo off
  ::  Look for name John Doe, get field #4
  awk "/John Doe/ {print \"set phone=\" $4}" FOO.DAT &gt;tmp_.bat
  call tmp_.bat
  echo John Doe's phone number is /<VAR>%PHONE%</VAR>/
  ::
  del tmp_.bat &gt;NUL
  set phone=
</pre>

<p>Of course, in situations like Example 2, you must write your sed or
awk script to ensure that you don't end up with more than one line of
data (and, optionally, that the total line length is under 127
characters).</p>

<p>Example 3: Prompt the user for a phrase and put it into the variable
 called <var>%phr%</VAR></p>

<pre>
  @echo off
  echo Enter a phrase and press the ENTER key:
  awk "{print \"set phr=\" $0;exit;}" &gt;tmp_.bat
  call tmp_.bat
  echo The line of words typed is "<VAR>%phr%</VAR>"
  del tmp_.bat &gt;NUL
  set phr=
</PRE>


<hr>
<h2>METHOD 4 (several DOS-only solutions):</h2>

<p>Two things are needed: your data directed to disk and a batch file.</p>

<p>First, if your data will come from console output (such as the screen
output of <CODE>ECHO, GREP, SED, WC, DATE, CALC, FIND,</CODE> etc.), you must
redirect the data to a disk file. The data must be one line only! For
example:</p>

<pre>
     echo Some sample data           &gt; ANSWER.DAT
     grep "pattern" MYFILE.TXT       &gt; ANSWER.DAT
     sed -n "/regexp/p" MYFILE.TXT   &gt; ANSWER.DAT
     wc -l &lt; MYFILE.TXT              &gt; ANSWER.DAT
     echo. | DATE | find "199"       &gt; ANSWER.DAT
     calc 87 * 55                    &gt; ANSWER.DAT
     find "this string" &lt; MYFILE.TXT &gt; ANSWER.DAT
</pre>

<p>However you obtain your data (sed, wc, calc, etc.), the point is that
the data may not be longer than one line. In fact, since MS-DOS cannot
handle command lines longer than 127 characters, <CODE>ANSWER.DAT</CODE> must be
several characters shorter than that. (Technically, 127 minus the
length of the string "<KBD>set&nbsp;your_variable_name=</KBD>", which will be
prepended to <CODE>ANSWER.DAT</CODE> later on.)</p>

<p>Second, in the batch file we need to be able to issue the command<p>

<pre>
      set MYVAR={the contents of ANSWER.DAT go here}
</pre>

<p>This is a difficult task, since MS-DOS doesn't offer an easy way to
prepend "<KBD>set MYVAR=</KBD>" to a file. There are at least six different
solutions available under MS-DOS without resorting to third-party utilities
(even though using a third-party program is the easiest solution). Technically,
there are two others that I am omitting here because, in my opinion, they are
more obtuse or difficult to use than the ones listed below. If you know of
any DOS-only solutions I haven't remembered, please
<a href="mailto:pemente@northpark.edu">let me know</a>. Thanks!</p>

<a name="linefeed"></a>
<H3>Solution (a): Embed a single linefeed in the batch file.</H3>

<p>Normal DOS text files and batch files end all lines with two
  consecutive bytes: a carriage return (Ctrl-M, hex 0D, or ASCII 13)
  and a linefeed (Ctrl-J, hex 0A or ASCII 10). In the batch file, you
  must be able to embed a Ctrl-J in the middle of a line.</p>

<p>Many text editors have a way to do this: via a Ctrl-P followed by
  Ctrl-J (DOS <CODE>EDIT</CODE> with Win95/98, <CODE>VDE</CODE>), via a Ctrl-Q prefix (<CODE>Emacs,</CODE>
  <CODE>PFE</CODE>), via direct entry with <KBD>ALT</KBD> and the numeric keypad (<CODE>QEdit,</CODE>
  <CODE>Multi-Edit</CODE>), or via a designated function key (<CODE>Boxer</CODE>). Other editors
  absolutely will not support this (<CODE>Notepad, Editpad, EDIT</CODE> from MS-DOS
  6.22 or earlier; <CODE>VIM</CODE> can insert a linefeed only in binary mode,
  but not in its normal text mode).</p>

<p>If you can do it, your batch file might look like this:</p>

  <pre>
     @echo off
     :: assume that the datafile exists already in ANSWER.DAT
     echo set myvar=<font color=red>^J</font> | find "set" &gt;PREFIX.DAT
     copy PREFIX.DAT+ANSWER.DAT  VARIAB.BAT
     call VARIAB.BAT
     echo Success! The value of myvar is: [<I>%myvar%</I>].
     :: erase temp files ...
     for %%f in (PREFIX.DAT ANSWER.DAT VARIAB.BAT) do del %%f &gt;NUL
</pre>

<p>Where you see the <font color=red>^J</font> on line 3 above, the linefeed should be
  embedded at that point. Your editor may display it as a square box
  with an embedded circle.</p>

<p>The drawback to this method is that some e-mail or Usenet programs
  automatically convert lone Ctrl-J characters to normal 2-byte line
  endings, so your batch files may not survive well over the Net.</p>

<a name="type"></a>
<h3>Solution (b): Prompt the user to type a line.</H3>

<P>This solution doesn't require any special text editor, but does
  require user assistance in making the batch file.</p>

<pre>
     @echo off
     :: assume that the datafile exists already in ANSWER.DAT
     echo.
     echo Type the words "set myvar=" (don't type the quote marks)
     echo and then immediately after the = sign, press Control-Z!
     copy con PREFIX.DAT
     copy PREFIX.DAT+ANSWER.DAT  VARIAB.BAT
     call VARIAB.BAT
     echo Success! The value of myvar is: [<I>%myvar%</I>].
     :: erase temp files ...
     for %%f in (PREFIX.DAT ANSWER.DAT VARIAB.BAT) do del %%f &gt;NUL
</pre>

<p>Note that this batch file cannot run unattended and that the user
  must manually create the <CODE>PREFIX.DAT</CODE> file on-the-fly. Do not press
  the <KBD>ENTER</KBD> key before pressing <KBD>Control-Z</KBD>.</p>

<a name="debug"></a>
<H3>Solution (c): Use DEBUG to create a temporary file.</H3>

<P>The following solution requires no user intervention, nor does it
  require single linefeeds in a DOS batch file. <CODE>DEBUG.EXE</CODE> is included
  in all standard distributions of MS-DOS and is in Windows 95/98 in
  <CODE>C:\WINDOWS\COMMAND</CODE>, so you can use it unless someone has deleted it.</p>

<pre>
     @echo off
     :: assume that the datafile exists already in ANSWER.DAT
     echo e 100 "set myvar="             &gt; TEMP.FIL
     echo n PREFIX.DAT                  &gt;&gt; TEMP.FIL
     for %%i in (rcx a w q) do echo %%i &gt;&gt; TEMP.FIL
     debug &lt; TEMP.FIL
     copy PREFIX.DAT+ANSWER.DAT  VARIAB.BAT
     call VARIAB.BAT
     echo Success! The value of myvar is: [<I>%myvar%</I>].
     :: erase temp files ...
     for %%f in (PREFIX.DAT ANSWER.DAT VARIAB.BAT TEMP.FIL) do del %%f &gt;NUL
</pre>

<p>Many people are skittish about using <CODE>DEBUG</CODE> and rightfully so, since
  <CODE>DEBUG</CODE> can crash a hard drive or delete files and directories.
  Therefore, here is an explanation of what the previous commands
  actually do. I obtained these commands from<I> Dan Gookin's Guide to
  Underground DOS 6.0</I> (Bantam Books, 1993), pp. 187-190, which tells
  quite a lot about using <CODE>DEBUG</CODE>. For the cautious user, here's what
  these commands mean to <CODE>DEBUG</CODE>:</p>

<pre>
     e 100 "set myvar=" ; at base address 100, Enter this "string"
     n PREFIX.DAT       ; "n" means set a filename called PREFIX.DAT
     rcx                ; in Register CX, set the size of the file
     a                  ; filesize A hex (10 bytes) put in register CX
     w                  ; Write the file set by "n", i.e., PREFIX.DAT
     q                  ; Quit DEBUG
</pre>

<a name="echo"></a>
<h3>Solution (d): Use ECHO to create an intermediate file</h3>

<p>(To be written)</p>

<a name="firstword"></a>
<h3>Solution (e): Get first word of a textfile into a variable</h3>

<p>(To be written)</p>

<a name="firstline"></a>
<h3>Solution (f): Get first line of a textfile into a variable</h3>

<p>(To be written)</p>

<p>Warning! In all these methods, note that they use temporary files
(<CODE>ANSWER.DAT, PREFIX.DAT, VARIAB.BAT</CODE>, and <CODE>TEMP.FIL</CODE>). We have assumed
that files with these names don't already exist on disk. If they do
exist, the batch file overwrites them without asking permission. If
these filenames might conflict with files on your computer, change
them to a filename not likely to be used, such as "<CODE>#PRE!.FIX</CODE>" or
"<CODE>}TMP{.FIL</CODE>" (yes, both these are legitimate filenames under MS-DOS).
</p>


<p>These different methods should help make handling DOS environment
variables easier. Please write me if you find any of these examples to
be unclear or in need of improvement.</p>


<p>Kind regards,</p>

<p>Eric Pement (Acts 17:29-31, Titus 2:11-14)</p>


<p>[eof]</p>
</body>
