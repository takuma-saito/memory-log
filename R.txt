R 言語の使い方
============================

emacs ess-mode のショートカット
----------------------------
* `(C-c C-b)`: パラグラフを実行し
* `(C-c C-r)`: 次行へ移動
* `(C-M-x)`:   現在行を実行し次行へ
* `(C-c C-c)`: 移動現在行のみ実行
* `(C-c C-t)`: ミニバッファに式を入れて実行
* `(C-c C-j)`: 関数・パラグラフを実行し次行へ
* `(C-c C-n)`: 移動関数を実行選択されている範囲（リージョン）を実行
* `(C-c C-p)`: バッファ全体を実行

R のプロット
----------------------------

図を重ね合わせる場合, plot した後に以下を指定する。

    > par(new=T)


メモ
----------------------------

### パッケージのインストール方法 ###

ミラーを選択する

    > chooseCRANmirror()
    Loading Tcl/Tk interface ... done

X Windows 上でミラーを選択し、閉じる。
その後は install.package を呼び出せばパッケージをインストールすることが出来る

    > install.package('hash')

### 可変長引数 ###

可変長引数は ... を使ってアクセスできる。
例として printf を定義する

    > printf <- function(fmt, ...) {  
      cat(sprintf(fmt, ...)) 
    }

### ハマりどころ ###

#### 関数リストへのアクセス ####

関数のリストを作る場合、ベクトルの中に匿名関数を入れる。
配列アクセスはなぜか `[[1]]` という形式でアクセスしなければならない。

    > fun <- c(function(x) {x ** 2}, function(x) {x ** 3})
    > fun[[2]](3)
    27

#### 関数リストのクロージャー ####

R ではクロージャーが壊れているので、一旦自分で変数をバインドしなければならない！

x ^ n をクロージャーに持つリスト。素直に下記のように書いても上手く動かない。

    > a <- function(length) {
      lapply(1:length, function(j) {
        function(x) {x ^ j}
      }
    }

原因は lapply された段階で j が最後まで評価されてしまうため。
この場合だと、全ての j において j = length が代入されてしまう。
そのため一旦一時変数を経由してから代入すると上手くいく。

    > a <- function(length) {
      lapply(1:length, function(j) {
        j_ = j; function(x) {x ^ j_}
      }
    }

R のコンパイラ作成者の中には Haskell を使ったことがある人はいなそうだ。
なぜこのような意味不明な仕様になっているのか、理解に苦しむ。


逆引き
------

* データフレームに特定の行数だけ入れる: `data <- read.csv("filename",nrow=10)`
* データの標準化: `result <- scale(data)[,]`



参考資料
----------------------------

* [ESS - Rjp](Wikihttp://www.okada.jp.org/RWiki/?ESS#j58966ae)


