CPU FLAG について解説
============================

fpu: Floating Point Unit
----------------------------

浮動小数点プロセッサ(演算処理装置)と訳される、浮動小数点演算を高速に行なうことを目的とした専用のプロセッサ、
あるいはCPU内部におけるそうした機能のこと. 
昔は CPUとFPU が統合されていなものも多かったが、現在ではほとんどのプロセッサがFPUをサポートしている.

tsc: Time Stamp Counter
----------------------------
**リセットされてから現在までのサイクル数**を保存している64ビットレジスタのこと.
（リセット := 電源が投入されてから, なので起動してから現在までのサイクル数を調べることができる)
サイクル数は EDX:EAX に保存される.
1GHzの動作周波数のCPUであれば、分解能は1ns（ナノ秒）となり、非常に高精度な分解能なことが分かる

通常 TSC はプログラムのパフォーマンスなどを判断するのに用いる.

例えば, ある関数ルーチンの最初と最後に tsc 命令を行い, それらの差分を取ると
その関数でどれだけサイクル数が消費されたかが分かる.
サイクル数が分かれば, その関数が処理にどの程度の時間やコストが掛かったか分かるのでパフォーマンスの測定できる..

しかし、この機能にはいくつか問題もある.
現在のマイクロプロセッサーは高速化のためout-of-orderというアーキテクチャを採用されており、
命令した通りに順番に実行されるとは限らない.
out-of-order とは in-order （順番に実行するプログラム）の反対で,
プログラムがどのような順番で実行されるか分からない.
そのため、 "RDTSC" は実際のサイクル数よりも小さくなることがある.

constant_tsc
----------------------------
CPUの動作クロックが変動しても一定の割合で増え続ける TSC のこと.

古いハードウェア上で tsc は問題なかったが、
CPU が省電力機能としてクロック数を変動できるようになったため問題が出てきた.

例えば 1GHz と 200MHz のクロック数の間で周波数を 100 回変化させて合計の tsc が 50000サイクルになったとする.
さて、この時の CPU 実行時間はどのくらいになるだろうか?

古い CPU ではクロック数が変化しないので, 50000 * 1nm と単純に求められるが上記の場合は上手くいかない.

それは以下のように周波数の違いによって, 1サイクル実行する時間は以下のように一定ではないからだ.

1GHz: 1nm
200MHz: 5nm

例えば, 1GHz に 20000サイクル, 2000MHz に30000サイクル掛かったという情報があれば 20000 * 1nm + 30000 * 5nm と時間を計測できる.
しかし, 現実にはどの周波数がどの程度のサイクル実行されたか分からないので原理的に実行時間を計測することが不可能なのだ.

この問題を解決するためには, 
動作クロックが変化しても一定の割合（例えば 1nm）で増え続けるタイムカウンタを用意すればよい.

それがこの constant_tsc カウンタのことである.

この constant_tsc カウントを用いればカウンタがどんな値になっても
基準値を掛ければ実行時間が出てくるので正確に実行時間を計測することができる.
また、基本的に基準値はチップの最高クロック数になる.

pebs: Precise Event Based. Sampling
----------------------------
イベントベースの CPU パフォーマンスモニタリング機能.
理解できない. 理解した後書く.

### コマンド関連 ###

* `pfmon -ers_uops_dispatched ls /dev/null`
* `pfmon -ers_uops_dispatched --counter-mask=2 ls /dev/null`
* `pfmon -ers_uops_dispatched,mem_load_retired:L1D_LINE_MISS --counter-mask=6,2 ls /dev/null`


msr: Model Specific Registers （モデル固有レジスタ）
----------------------------

CPUの実装に依存する、各種ハードウェア機能を制御するレジスタ群. 

以下の CPU 機能利用する際にデータの読み書きが行われるレジスタ群のことを指す.

* mtrr（メモリタイプ範囲レジスタ）: 特定のメモリ範囲の種類を設定することにより高速なバス転送を可能にする
* pebs, dts （性能モニタリング）: CPU内部のパフォーマンスを測定するためのレジスタ. 
* mca（Machine Check Architecture）: CPU内部のエラー状態を検知する
* パワーマネジメント制御: 電源の管理など

普通のレジスタを利用するとパフォーマンスや互換性、
アーキテクチャの点で問題があるので、このような固有レジスタを用意している.

### コマンド関連 ###*

msr-tools をインストールすることでMSRの状態を調べることができる.
（カーネルの CONFIG_X86_MSR を y にしていなければならない）

* `rdmsr`: msr に読込ができる
* `wrmsr`: msr に書込ができる

pae : Physical Address Extension （物理メモリ拡張）
----------------------------

4GB までのメモリ制限を CPU 側で拡張する機能.

昔のCPUの場合4GB以上の物理メモリを搭載しても 32bit 向けのプロセッサーでは
**4GB以上のメモリは認識でない**、という制限が存在する.
なぜならば CPU のレジスタから見えるメモリはアーキテクチャ上 32Bit までのため。（2 ^ 32 = 4G）
それを 36ビット以上のメモリ空間で扱えるようにするのが PAE.

ページテーブルという技術を利用して実現している.（関連 PAE-36）

mce: Machine Check Exception（マシンチェック例外）
----------------------------

CPUがハードウェアの回復不能なエラーを検出した場合の処理で、
CPU、キャッシュ、システムバス、メモリ等のエラーが検知できる.

* メモリバスエラー: メモリとマザーボードの間の接続エラー
* メモリエラー: メモリのRAMにデータが正しく保存されていない. パリティやECC（Error Check Code）の不一致.
* キャッシュエラー

ちなみに上記エラーが発生する原因としては以下が考えられる.

* CPUのオーバークロック
* CPUファンにホコリが溜まっている or ファンが正常に機能していない
* 電源の供給過多

### コマンド関連 ###

* `mcelog`: 過去のmceエラーを参照できる.
* `mced`: カーネルのMCEエラーを集め, アプリケーションに通知する

cx8 : CMPXCHG8B命令をサポート
----------------------------

cmpxchg8b 命令を使えるようになる.
この命令を実行すると、edx:eaxの値とメモリ上の8byte値を比較し、
一致したらZフラグをセットするとともにecx:ebxの値をこの8byte領域にストア.
一致しなければZフラグをクリアするとともに8byteのデータをedx:eaxにロードする.
この命令は、前にLOCK プリフィックスを付けることにより、自動的に実行させることができる。

*注意)* 特定の Pentium プロセッサーでは、lock cmpxchg8b f00f 
を実行するとハングアップするバグが存在し、再起動以外の命令を受け付けなくなるバグが存在している.
詳しくは [wiki](http://ja.wikipedia.org/wiki/Pentium_F00F_%E3%83%90%E3%82%B0) を参照のこと.

apic: Advanced Programmable Interrupt Controller
----------------------------

x86アーキテクチャにおける割り込みコントローラのこと。
割り込みリダイレクト処理やプロセッサーへの割り込み命令がAPICの前のバージョンの PIC よりもより洗練されている.

mtrr : Memory Type Range Register、メモリタイプ範囲レジスタ
----------------------------

メモリタイプを設定することの出来るレジスタ群のこと.

用途として多いのがグラフ描画処理の高速化.
ビデオカードのメモリ領域に WC（Write Combing）タイプを指定すると高速になる.
指定できるメモリタイプは以下の通り.

* UC （Uncacheable、ストロング・キャッシュ不可）
* UC-  (Uncacheable、ストロング・キャッシュ不可、オーバーライド可能）
* WC （Write Combing）
   WC は、CPU -> Memory 間のデータ書込みが多重に発生した場合、最後に書き込まれたデータ以外は破棄する。
   書き込み遅延が生じにくく、データ転送量も少なく見積もることが出来るので高速なデータ転送が期待できる.
   特に書込タイミングを保証する必要のないフレームバッファ（ディスプレイに表示する画像のラスタデータを一時的に保存するメモリのこと）に向いている.
* WT (Write-through)
* WB (Write-back)
* WP (Write protected)

### コマンド関連 ###

* `cat /proc/mtrr` : mtrr 情報を表示する
* `echo "disable=1"  > /proc/mtrr`: 設定をクリアする
* `echo "base=0xe2000000 size=0x2000000 type=write-combining" > /proc/mtrr`:
   0xe2000000 を基点として 0x2000000 までのメモリをWCに設定する
* `dmesg | grep vesa`: フレームバッファーサイズを調べる

mca : Machine Check Architecture.
----------------------------

CPU がハードウェアのエラーを検知し、そのエラーをオペレーティング・システムに通知する仕組み.
バスエラーやECCエラー・パリティエラーなどのハードウェアエラーを検知することができる. 
どのようなエラーが発生したかなどの情報は、モデル固有レジスタ（MBR）に書き込まれる.

### コマンド関連 ###
* `sysctl hw.mca`: 現在の MCA の状態を確認する

cmov: cmov 命令をサポートする
----------------------------

特定の条件に基づいて mov を行う命令.
cmov の後ろの命令がその条件になっている.

例）
cmpl %eax, 12(%ebp)
cmovge 12(%ebp), %eax

上記の例の場合 cpml で %eax と 12(%ebp) を比較している.
この条件が真となった場合のみ cmovge 12(%ebp), %eax 命令が実行される.
通常この主の条件分岐を伴う命令には jmp が必要だが、それを省くことができる.

（注意）jmp 命令と cmov 命令を置き換えたところで、命令の数に大差はないので何か意味があるのか？と思う方がいるかもしれません. 
しかし現代のプロセッサーのアーキテクチャ上では jmp 命令を行うだけで 数十サイクルロスするので上記のコードの方が実際には早くなります.
CPU の中では、CPU の命令を解釈する ⇒ 実行する ⇒ レジスタに値を書き込む など複数のパイプラインを繋いで実行することによりクロック数を上げています. しかし、 jpm 中はパイプライン処理が止まってしまうため上記のような大幅なクロック遅延に陥る原因です. ちなみにそれを防ぐため最近のCPUでは条件分岐の先読みなども行なっています.
 
pbe : Performance Boost Engine
----------------------------

より早くメモリアクセスができる技術.
使用するバスを最適化することにより, プロセッサとメモリ間におけるアクセス速度と品質を ３%～５%向上させる. 
 
pse36 : Page Size Extension
----------------------------

物理メモリのサイズを 32Bit から 36Bit に拡張できる.（詳しくは pae を参照）
 
dts: Digital Thermal Sensor
----------------------------

CPUの温度を測定できるようになる.
プロセッサーの最も熱い部分の近くに温度感知センサーを置かれており、そのセンサーによって温度を計測している. 
計測された温度は、特殊なレジスタにその値が書き込まれソフトウェアによって自由に読込ができる.
CPUの温度を感知する coretemp などのカーネルドライバはこの機能を使ってCPUの温度を計測している.
 
fxsr: 
----------------------------

 FXSAVE/FXRSTOR. (The FXSAVE instruction writes the current state of the x87 FPU, MMX technology, Streaming SIMD Extensions, and Streaming SIMD Extensions 2 data, control, and status registers to the destination operand. The destination is a 512-byte memory location. FXRSTOR will restore the state saves)


mmx: MultiMedia eXtension
----------------------------
CPU でベクトルを扱う演算を行えるようにする技術.

もう少し技術的に説明すると, x87 浮動小数点演算用のレジスタを転用し、
1つの命令で同時に*複数の整数演算*を扱うSIMD技術.
MMX にはこのような命令を56個含む.

MMXによって高速化できるのは整数演算処理に限られ、
浮動小数点演算処理を多用する3Dグラフィックス関連の処理能力の向上は期待できない.

また MMX は現在では非常に古い技術であり 
Intel などのCPUメーカーも MMX は後方互換性のために実装しているだけで
MMX の使用を避けることを推奨している.

SSE や AVX などが MMX の上位互換として実装されているので, 
ベクトル演算を行いたい場合はこれらの命令セットを使う.

### SIMD 技術とは ###
SIMD 技術とは single instruction multiple data の略で1回の命令で複数のデータを*同時並行的*に処理する手法のこと.
1つの命令で複数の並列的な処理が行えるので、
音楽・画像・動画などのマルチメディア関係の処理を高速化できる.

歴史的に見ると, 昔のパソコンやワークステーションはまだ高価で個人向けに利用されておらず
このような SIMD技術はあまり必要とされていなかった.
しかしハードウェアの進化や, Windows 95 OSの普及などに伴い, パソコンを個人でも扱える時代になったことで
音楽や画像、動画などのメディア向けの演算の高速化が次第に重要になってきた.
そこで, 1997年に初めて Intel が CPU にマルチメディアを専用に扱う命令セットが SIMD 技術を搭載した MMD である.

その後 MMX 命令セットは SSE, SSE2, SSE3, SSSE3, SSE4, SSE4a, AVX, AVX2 と拡張を重ねている.

また, 3Dを快適に扱うためパソコンへグラフィクスボードを追加することがあるが
このようなグラフィクスボードは SIMD 演算に特化した CPU とみなすことができる.

*疑問*
* なぜ浮動小数点演算を行うレジスタを利用しているのに, 整数演算処理に限られるのか ?

sse: Streaming SIMD Extensions 
----------------------------
MMX の拡張技術.
x86アーキテクチャに8本の128bitレジスタを新設し、
浮動小数点演算のSIMD処理を実現したもの.
追加された命令数は70
 
sse2: Streaming SIMD Extensions Ver.2
----------------------------
SSE の拡張技術.
SSE2は従来のSSEに144個の新たな命令が加えられ、一度に扱えるデータの数も増加した.
具体的には64ビットの倍精度浮動小数点データ及び整数演算の追加、キャッシュの制御機能の強化がされた.

sse3: Streaming SIMD Extensions Ver.3
----------------------------
SSE2 の拡張技術.
SSE3はSSE2に13個の新たな命令が加えられた.
具体的にはメモリアクセス及び複素数計算の高速化、
仮想CPUのスレッドの動作制御などの機能が搭載され、主に動画圧縮の処理が向上した.

ssse3: Streaming SIMD Extensions
----------------------------
SSE3 の拡張技術.
SSSE3はSSE3に32個の新たな命令が加えられた.

sse4_1: Streaming SIMD Extensions Ver.4
----------------------------
SSSE3 の拡張技術.
54個の命令が追加になる.

tm: Thermal Monitor （オーバーヒート保護機能）
----------------------------
CPU が一定以上の温度に達すると, 自動で性能を落として温度を冷ますセーフティー機能のこと.

CPU 温度が閾値（約 80～85 度）を超えると、CPU のスピードとコア電圧を自動的に下げ,
温度が安全な範囲に下がると, CPUのスピードも元のフルスピードに戻す.

tm2: Thermal Monitor 2 （オーバーヒート保護機能）
----------------------------
Thermal Monitor 1 の強化版.
ユーザーが BIOS で使用限界温度を設定できる.
TM1 ではこの値はハードコードされていたが、TM2 ではユーザー側で設定できるようになっている.
使用するCPUのメーカー, 動作周波数によって使用限界温度は異なるので
この値を設定する際にはCPUのデーターシートを参考にすること.

ユーザーが閾値を設定できるようなったこと以外 TM1 との違いは存在しない.

nx: No Execute Bit
----------------------------
NX ビットは特定のメモリ領域に付与する*プログラム実行不可属性機能*を指す.
NXビットは、端的に言えば「データの誤実行」を防ぐために用いられる.

通常メモリ領域はプロセッサーへの命令を行う実行領域と,
単純なデータを表すテキスト領域に分類することができる.
しかしフォン・ノイマン型PC上ではデータもプログラムも基本的に同じビットとして解釈されるので
これらの違いを区別することができない.
そのため**データを実行することができてしまう**, という点が問題になる.

通常データを実行することはできない. 

例えばあなたが機能撮影した写真を .exe 形式で保存し実行するとしよう.
このファイルを実行すると通常エラーになる.
それは当たり前かもしれないが, フォン・ノイマン型コンピューター上では次のような奇跡が起こる可能性もある.

+ 宇宙論的な偶然によってあなたの写真がピンボールゲームのビット列と寸分違わず一致しており, 実行してみたらピンボールゲームで楽しく遊ぶことができた.
+ 写真のビット列の一部がたまたまメールプロトコルを解釈・実行することができ, 実行したところビルにメールが届いた.
+ 写真のビット列の中にあなたのPCを遠隔操作するプログラムが埋め込まれており, 外部のハッカーが自由にあなたのPCへ侵入することができるになってしまった.

ありそうにもないが, もし上2つの例が実現出来たとしても特に問題はないだろう.
しかし最後の1つはセキュリティ的に考えて, 非常に問題がある.
さらにこれが偶然ではなく意図的に出来るとしたらどうだろうか.

また、このアーキテクチャを悪用したよく知られた攻撃としてバッファーオーバーフロー攻撃がある.

このようなセキュリティ脆弱性を防ぐためにも, データとプログラムは区別する必要がある.

ではどうするか？

メモリ上にプログラムを表すマークと, データを表すマークを付け、データを表すメモリを実行できないようにすればよい.
これがマークのことこそ NXビット である.

ちなみにこの NX ビットは通常ベージテーブル上に記述する.

この機能がハードウェアに搭載される前には, 
数々のオペレーティングシステムが, Exec Shieldなど
ソフトウェアを通してこの機能を実現しようとした.

### バッファーオーバーフロー攻撃とは ###
あとで書く.


sep: Fast System Call
----------------------------
SYSENTER 命令および SYSEXIT 命令, SYSENTER, SYSEXIT および関連する命令をサポート.

ss: Self Snooping
----------------------------


cid: Context ID adaptive or shared L1 Data
----------------------------
 
ht : Hyper-Threading
----------------------------

xtpr: 
----------------------------

vnmi
----------------------------
 
pat: Performance Accelerating Technology
----------------------------


clflush: Cache Line Flush
----------------------------

syscall
----------------------------

acpi: 
----------------------------

* C0, 通常動作状態：OSなどでアプリケーションなどが実行されている
* C1, Halt状態：Halt命令の実行によりCPUコアのクロックが停止
* C2, クロック停止：CPUコアとバスのクロックが停止
* C3, Deep Sleep：クロック生成機も停止
* C4, Deeper Sleep：Vcc(CPUへの供給電圧)を低減


lm: Long Mode
----------------------------
CPU が 64 ビットをサポートしていることを示す.

arch_perfmon
----------------------------


bts: Bit Test and Set (BTS命令をサポート）
----------------------------
レジスタ／メモリの指定したビットをキャリーフラグ(CF)にコピーし, テストしたビットをセットする.
第１オペランドがテストするレジスタ／メモリ, 第２オペランドがビットオフセットを指す.

CF（キャリーフラグ）とは, 通常の演算結果で桁あふれが発生した時にセットされるレジスタフラグのこと.

rep_good
----------------------------

aperfmperf
----------------------------


monitor: MONITOR MWAIT 命令をサポートする
----------------------------
Monitor Wait 命令の目的は2つに分類させる.

1. メモリ範囲を指定してそのデータ構造の変化を監視すること.
2. PCのパワーマネジメントを管理すること.

データ構造の観点からこれらの命令を意味を考えてみる.

メモリ中の任意のデータ構造を監視する機能がほしいとする.

なぜこのような機能が必要かは以下の例を考えれば分かるかもしれない.

例1）キューにデータが100個溜まるまで監視したい
例2) ハッシュ木の長さが 100 を超えた時, 再ハッシュして 10倍のハッシュ木を得たい

上記のような例は以下の様な擬似コードで表現できる.

     Loop
       ...
       insert queue value 
       if (is_queue_full? queue) then exit Loop
     Loop end

しかし注意してほしいのは, 上記の例が期待した通りに動作するのはシングルプロセスの時だけで, 
共有メモリを持つマルチプロセッサーでは上手く動作しない.

というのも複数のプロセスが非同期的に queue へ書込を行うので
きっかり 100 を超えた時点を正確に特定できないからである.

これらの操作を簡単に処理するため MONITOR 命令と MWAIT 命令が導入された.

さて, ここからは話を簡単にするために特定メモリ中のデータ1個のみで考えることにする.
擬似コードで書くと以下のように表現できるだろう.

     Loop 
       # レジスターに値をロードする
       register := load (memory)
       
       # 条件がみたされていれば終了する
       if (condition(register)) then exit Loop
     End Loop

ここで condition 関数は register が満たすべき条件である.

     # 以下は condition 関数の例の一つである
     function condition(reg) = 
        reg == 30 || reg == 21

上記の擬似コードでは Loop が何度も評価されるので非常に非効率である.
しかもメモリーとレジスター間のデータ転送を何度も行わなければならない.

そこで以下のように少し時間を置いてからループ文を評価するようにコードを変更したとする.

     Loop 
       register := load (memory)
       if (condition(register)) then exit Loop

       # 100 サイクル待った後コードを実行する
       sleep 100        
     End Loop

これでもまだ非効率な上に register の値が変わった時間を正確に特定できなくなってしまった.
つまり、粒度が 1 サイクルから 100 サイクルに変わってしまった.
ここで次のような命令に変更する.

     Loop 
       register := load (memory)
       if (condition(register)) then exit Loop

       # 他のプロセッサーが memory に値を書き込むまで待つ
       mwait (memory)
     End Loop

mwait を入れたとこで memory を効率的に監視できるようになった.
実は上記の文章コメントには間違いがある.
メモリーにはキャッシュなどメモリー階層を通してしかアクセスできないので正確には以下のように解釈しなければならない.

    Loop 
       register := load (memory)
       if (condition(register)) then exit Loop

       # 他のプロセッサー memory で指しているキャッシュラインが変更された時
       mwait (memory)
     End Loop

注意してほしいのは, memory に書込が行われた場合ではなく
memory で指しているキャッシュラインに変更が行われた場合に mwait が処理を返すことである.

memory に書込が行われた以外にも mwait は処理を返す.
例えば, コンテキストスイッチでキャッシュラインで指しているデータが変更された場合や
CPU の省電力モードへの切り替えなどにより変更された場合などである., 

したがって memory が書き込まれたタイミングで正確に mwait が処理を返すわけではない.
最後に MONITOR 命令の初期化処理を入れてコードが完成する

    MONITOR (memory)
    Loop 
       register := load (memory)
       if (condition(register)) then exit Loop

       # 他のプロセッサー memory で指しているキャッシュラインが変更された時
       MWAIT (memory)
     End Loop

パワーマネジメントの場合は
レジスターに電力レベルを入力し mwait を実行することで指定された省電力モードに入ることができる.
逆に省電力モードが終了した場合, mwait の次の命令から通常通り実行される.
ちなみに, mwait で指定する電力レベルは C-State で記述されるが
これは ACPI のCレベルとは関係ない.

pni
----------------------------

dtes64: 
----------------------------

ds_cpl: CPL-Qualified Debug Store
----------------------------

vmx: Virtual Machine Extension
----------------------------

x86 の仮想化支援機構のこと.
KVM など一部の仮想化ソフトウェアは cpu の仮想化支援機構がないと実行できない.
ゲスト OS 間でのタスク切り替えという本来 OS 側で行なっていた処理を cpu レベルでサポートしており
異なる OS 間で上手くハードウェア資源を管理できるような VMM という機構を用意している.

通常 OS の上で実行できるアプリケーションの命令レベルは限られている.
そのためソフトウェアレベルでの仮想化では, カーネルレベルの命令に対して全てに対して割り込みを行い
この割り込み処理でゲスト OS が本来実現したかったこと（ハードウェアへのアクセスや特権レベルの命令実行など）をエミュレートしなければならない.

ソフトウェアレベルで OS の仮想化も実現できるが,
異なる OS 間でのタスクの切り替えのオーバーヘッドが非常に大きい.

この方法ではパフォーマンスに非常に問題があるので
Xen などはパラバーチャライゼーション（準仮想化）という方法が取られている.
割り込み処理を入れるのではなくカーネルのソースコードを直接変更, 
権限が必要な処理を仮想マシン側に渡すことによってこれらのオーバーヘッドをなくしている.

ただしこの方法でもやはりゲスト OS 間での切り替えに問題がないとは言えない.
また、それだけでなく準仮想化の場合はソースコードに直接変更を加えなければならないため
異なる OS 間での仮想化（例えば, Windows と Linux）が行えないというデメリットがある.

1. パフォーマンスの改善
そこで、それぞれの**ゲスト OS の状態を管理する領域を CPU 側で用意**することで
OS 間での処理機に切り替えに掛かるパフォーマンスの問題を解決した.
これらの領域を vmcs (Virtual Matchine Control Structure) という.

またハードウェアリソースなどについても, 
ゲスト OS とゲストOSを実行する OS の権限レベルを分けることで効率的にアクセスできるようになっている.

2. 異なる OS 間での仮想化
CPU の仮想化では上記で述べたようなソースコードに直接手を加えるような準仮想化ではなく
各命令を割り込み（トラップ）して状態を切り替えるので, 異なる OS 間でも仮想化ができる.


smx
----------------------------

est
----------------------------

cx16
----------------------------

xtpr
----------------------------

pdcm
----------------------------

xsave
----------------------------


lahf_lm
----------------------------

trp_shadow
----------------------------

flexpriority
----------------------------

vme: Virtual 8086 Mode Enhancements （仮想8086モード）
----------------------------
8086用（16ビット・リアルモード）用の命令を 32 ビットプロテクトモード化でエミュレートするCPUの動作モード.

通常 32 ビットプロテクトモード化では 8086 用のプログラムは実行できない.
それを CPU 側でエミュレートし, 32ビットプロテクトモードでも 8086 用のプログラムを動かすことができる.
8086（16ビット） と 386（32ビット） ではアーキテクチャが大きく異なり基本的に互換性がないので
その後方互換性を担保するために存在する.

2012年現在では 64 ビットCPUが一般になっているので基本的にこのモードを使うことはない.

ちなみに この 8086 から 386 の移行期の時期に Linux が生まれた.
この時期は丁度 8086 系から 386 系に移行する過渡期だったため
フルに 386 の機能を実行できる OS が存在しなかった.
それが理由の一つで Linus は Linux を自作したらしい.
（その他にも Unix の著作権の関係でフリーな OS がなかったことも理由として挙げられている）


de: Debugging Extensions （デバック拡張）
----------------------------
性能向上のため、デバックレジスタ DR4 と DR5 が参照された時未定義の例外（#UD）を発生される.
CR4 の DE ビットが on になっているとこの拡張が有効になる.

ちなみに DR4 も DR5 もデバック用の予約済レジスタで, レジスタとしては使われていない
すなわち現時点では意味のないレジスタである.

### IA32 のデバック機構について ###

デバックはプログラムの任意の点にブレークポイントを設定し,
その時点でのレジスタやシステムの状態を調べることによって行う.
そのためには例外を捕捉し、デバック用処理に制御へ移行する必要がある.

具体的に必要なのは以下の3点.

*デバック要件* 
1. 例外が発生するプログラムカウンタの値（= メモリの位置）
2. 例外が発生する条件（書込, 読込）
3. デバック用のプロセスへの制御移行（例外ハンドラー）

IA32 では DR0 〜 DR7 までのレジスタをデバックレジスタとして利用しており,
上記3つの要素は以下のように実現されている.

1. DR0 〜 DR3
これらのレジスタには, ブレークポイントとして設定するプログラムカウンタの値を設定できる. デバック要件の"1" に対応している.
ただし注意しなければならないのは、設定できるレジスタは4つに限られていること.
4 つよりも多くブレークポイントを設定したい場合にはブレークポイント例外を用いなければならない.

ブレークポイント例外は int 3 の命令によって発生する.
この例外も基本的にデバック例外と同じで、その後処理はデバック用のいプロセスに転送させる.

2. DR4, DR5
上記で説明した様にに予約済のレジスタで今のところは利用されていない.
DE ビットが on になっている場合未定義例外を発生させる

3. DR6
DR6 はデバックステート・レジスタである.
ブレークポイントの条件が満たされているかどうか, タスクスイッチからの例外かどうかなどを判断する.

4. DR7
DR7 はデバック制御レジスタである.
このレジスタで各ブレークの例外発生条件を指定することができる.
例外発生条件は以下の4つである.
・読み出しか
・書き出しか
・DRn で指定されるアドレス範囲は 1, 2, 4バイトのどの範囲か
・どのタスク範囲でブレークポイント例外を発生させるか（グローバル or ローカル）

この DR7 はデバック要件の "2" に対応している.

デバック要件の"3"に対応するレジスタはデバックレジスタ中には存在しない.
例外発生時の制御の移行は IA32 の例外処理中で行われる.

概要を述べると, 例外と例外捕捉ルーチンがそれぞれ対応するテーブルをメモリ中に確保しており
例外が発生するとそのテーブルを参照し対応するルーチンに制御が移る.

そのため, デバック例外やブレーク例外が発生した時に
デバック用のプログラムが動作するようにこの例外対応テーブルをセットすればよい.

ds: Debug store
----------------------------
メモリにデバック情報を書き込む機能をサポート.
分岐トレースストアと PEBS にて利用される.

PEBS については前項で説明したので, 分岐トレースストアについて説明する.


cpu の調査をする時の便利コマンドなど
============================

* `cpuid`: CPU に関する詳細な情報を出力してくれる
* `dmidecode`: BIOS に関する情報を出力してくれる, バージョンによってはCPUフラグも詳細に表示する
* `lscpu`: CPU に関する総合的な情報が分かる
* `cat /proc/cpuinfo`: 個々のコアごとに CPU の詳細を表示してくれる

ちなみにバイナリレベルでは cpuid 命令によってこれらの情報を得る.


/proc/cpuinfo の読み方
----------------------------


 参考資料
============================
 
http://blog.incase.de/index.php/cpu-feature-flags-and-their-meanings/
http://blog.hbcom.info/archives/152cmpl

Intel が発行している IA32 のアーキテクチャ資料
